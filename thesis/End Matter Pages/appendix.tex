%% appendix.tex â€” Appendices
%% Included via \input{End Matter Pages/appendix}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Appendices}

\appendix

% =============================================================================
\chapter{OpenQASM Circuit Examples}
\label{app:circuits}
% =============================================================================

Representative quantum circuit implementations from the QTwin platform, constructed using Qiskit and exportable to OpenQASM 2.0.

\section{QAOA Circuit for Combinatorial Optimization}
\label{app:qaoa_circuit}

The QAOA circuit implements $p$ layers of alternating problem and mixer unitaries, with parameters $\gamma$ and $\beta$ optimized classically.

\begin{lstlisting}[language=Python, caption={QAOA circuit implementation for treatment optimization.}, label={lst:qaoa_appendix}]
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
import numpy as np

def create_qaoa_circuit(n_qubits, p_layers, problem_graph):
    """
    Create a parameterized QAOA circuit for combinatorial
    optimization problems.

    Args:
        n_qubits: Number of qubits (decision variables)
        p_layers: Number of QAOA layers (circuit depth)
        problem_graph: List of (i, j, weight) tuples
                       encoding the objective function

    Returns:
        Tuple of (QuantumCircuit, gamma_params, beta_params)
    """
    gamma = [Parameter(f'gamma_{i}') for i in range(p_layers)]
    beta = [Parameter(f'beta_{i}') for i in range(p_layers)]

    qc = QuantumCircuit(n_qubits)

    # Initial uniform superposition |+>^n
    for i in range(n_qubits):
        qc.h(i)

    # Alternating QAOA layers
    for layer in range(p_layers):
        # Problem unitary U_P(gamma):
        # exp(-i * gamma * C) via ZZ interactions
        for (i, j, weight) in problem_graph:
            qc.cx(i, j)
            qc.rz(gamma[layer] * weight, j)
            qc.cx(i, j)

        # Mixer unitary U_M(beta):
        # exp(-i * beta * B) via RX rotations
        for i in range(n_qubits):
            qc.rx(2 * beta[layer], i)

    qc.measure_all()
    return qc, gamma, beta
\end{lstlisting}

\section{Variational Quantum Classifier}
\label{app:vqc_circuit}

The VQC uses angle encoding for input features followed by entangling variational layers with circular CNOT connectivity.

\begin{lstlisting}[language=Python, caption={Variational quantum classifier for medical imaging.}, label={lst:vqc}]
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
import numpy as np

def create_vqc_circuit(n_qubits, n_layers, n_features):
    """
    Create a Variational Quantum Classifier circuit.

    Args:
        n_qubits: Number of qubits
        n_layers: Number of variational layers
        n_features: Number of classical input features

    Returns:
        Tuple of (QuantumCircuit, input_params, var_params)
    """
    input_params = [Parameter(f'x_{i}')
                    for i in range(n_features)]
    var_params = [[Parameter(f'theta_{l}_{q}')
                   for q in range(n_qubits)]
                  for l in range(n_layers)]

    qc = QuantumCircuit(n_qubits)

    # Feature map: angle encoding of input data
    for i in range(min(n_features, n_qubits)):
        qc.ry(input_params[i], i)

    # Variational ansatz layers
    for layer in range(n_layers):
        # Single-qubit rotation layer
        for q in range(n_qubits):
            qc.ry(var_params[layer][q], q)
        # Circular entangling layer
        for q in range(n_qubits):
            qc.cx(q, (q + 1) % n_qubits)

    qc.measure_all()
    return qc, input_params, var_params
\end{lstlisting}

\section{OpenQASM Export Example}
\label{app:qasm_export}

A representative OpenQASM 2.0 export from a 4-qubit, 2-layer QAOA circuit with optimized parameters.

\begin{lstlisting}[caption={OpenQASM 2.0 output for a 4-qubit QAOA circuit.}, label={lst:qasm}]
OPENQASM 2.0;
include "qelib1.inc";

// QAOA circuit for treatment optimization
// Generated by QTwin Platform
// Module: Personalized Medicine
// Qubits: 4, Layers: 2

qreg q[4];
creg c[4];

// Initial superposition
h q[0];
h q[1];
h q[2];
h q[3];

// Layer 1 - Problem unitary (gamma_0 = 0.7854)
cx q[0], q[1];
rz(0.7854) q[1];
cx q[0], q[1];
cx q[1], q[2];
rz(0.7854) q[2];
cx q[1], q[2];
cx q[2], q[3];
rz(0.7854) q[3];
cx q[2], q[3];

// Layer 1 - Mixer unitary (beta_0 = 1.2566)
rx(2.5133) q[0];
rx(2.5133) q[1];
rx(2.5133) q[2];
rx(2.5133) q[3];

// Layer 2 - Problem unitary (gamma_1 = 0.3927)
cx q[0], q[1];
rz(0.3927) q[1];
cx q[0], q[1];
cx q[1], q[2];
rz(0.3927) q[2];
cx q[1], q[2];
cx q[2], q[3];
rz(0.3927) q[3];
cx q[2], q[3];

// Layer 2 - Mixer unitary (beta_1 = 0.6283)
rx(1.2566) q[0];
rx(1.2566) q[1];
rx(1.2566) q[2];
rx(1.2566) q[3];

// Measurement
measure q -> c;
\end{lstlisting}

% =============================================================================
\chapter{API Endpoint Reference}
\label{app:api}
% =============================================================================

REST API endpoints exposed by the QTwin backend. All endpoints return JSON; authenticated endpoints require a JWT in the \texttt{Authorization} header.

\begin{table}[htbp]
\centering
\caption{QTwin platform REST API endpoint reference.}
\label{tab:api_endpoints}
\begin{tabular}{l l l c}
\hline
\textbf{Method} & \textbf{Path} & \textbf{Description} & \textbf{Auth} \\
\hline
POST & \texttt{/api/auth/register} & Register a new user account & No \\
POST & \texttt{/api/auth/login} & Authenticate and obtain JWT & No \\
\hline
GET & \texttt{/api/twins} & List all twins for current user & Yes \\
POST & \texttt{/api/twins} & Create a new digital twin & Yes \\
GET & \texttt{/api/twins/\{id\}} & Retrieve twin details by ID & Yes \\
DELETE & \texttt{/api/twins/\{id\}} & Delete a twin by ID & Yes \\
\hline
POST & \texttt{/api/conversation/message} & Send message to conversational AI & Yes \\
GET & \texttt{/api/conversation/\{twin\_id\}/history} & Retrieve conversation history & Yes \\
\hline
POST & \texttt{/api/benchmark/run/\{module\}} & Execute benchmark for a module & Yes \\
GET & \texttt{/api/benchmark/results/\{id\}} & Retrieve benchmark results & Yes \\
\hline
GET & \texttt{/api/data/export/\{twin\_id\}} & Export twin data as JSON & Yes \\
\hline
\end{tabular}
\end{table}

Authentication routes are public; all others require a valid JWT.

% =============================================================================
\chapter{Sample Conversation Transcripts}
\label{app:conversations}
% =============================================================================

Annotated transcripts demonstrating entity extraction, domain classification, and quantum algorithm selection.

\section{Healthcare Domain: Emergency Department Optimization}
\label{app:conv_healthcare}

Multi-turn entity extraction and algorithm selection for hospital emergency department optimization.

\begin{description}

\item[Turn 1 --- User:] \hfill \\
\textit{``I want to build a digital twin for a hospital emergency department.''}

\item[Turn 1 --- System (internal):] \hfill \\
Entities detected: \texttt{hospital}, \texttt{emergency\_department}. Domain: \texttt{healthcare}. Status: \texttt{DRAFT}.

\item[Turn 1 --- System (response):] \hfill \\
\textit{``I've identified a hospital operations scenario focused on an emergency department. To build an effective digital twin, I need to understand more about the system. What specific aspects would you like to model? For example, are you interested in patient flow, staffing schedules, resource allocation, or wait time optimization?''}

\item[Turn 2 --- User:] \hfill \\
\textit{``Yes, I want to optimize patient flow and reduce wait times. We have about 200 patients per day, 15 beds, and 3 triage levels.''}

\item[Turn 2 --- System (internal):] \hfill \\
Entities added: \texttt{patients}, \texttt{beds}, \texttt{triage}, \texttt{wait\_times}, \texttt{patient\_flow}. Goal: \texttt{optimization} $\rightarrow$ algorithm: \textbf{QAOA}. Activation threshold met. Status: \texttt{DRAFT} $\rightarrow$ \texttt{ACTIVE}. QAOA circuit: $n = 15$ qubits, $p = 2$ layers.

\item[Turn 2 --- System (response):] \hfill \\
\textit{``Here is what I've extracted: Healthcare---Hospital Operations, 200 patients/day, 15 beds, 3 triage levels. Objective: optimize patient flow and minimize wait times using QAOA. Your quantum digital twin is now active with circuits available in OpenQASM format.''}

\end{description}

\section{Military Domain: Supply Chain Logistics}
\label{app:conv_military}

Cross-domain generalization: the same pipeline applied to a military logistics problem.

\begin{description}

\item[Turn 1 --- User:] \hfill \\
\textit{``Create a digital twin for military supply chain logistics.''}

\item[Turn 1 --- System (internal):] \hfill \\
Entities detected: \texttt{military}, \texttt{supply\_chain}, \texttt{logistics}. Domain: \texttt{military}. Status: \texttt{DRAFT}.

\item[Turn 1 --- System (response):] \hfill \\
\textit{``I've identified a military logistics scenario involving supply chain management. To create an accurate digital twin, I need more details about your system. Could you describe the key components? For instance, how many supply depots, transport vehicles, and delivery routes are involved? What is the primary objective --- minimizing delivery time, reducing costs, or maximizing throughput?''}

\item[Turn 2 --- User:] \hfill \\
\textit{``We have 5 forward operating bases, 12 supply vehicles, and 8 routes connecting them. The goal is to minimize delivery time while ensuring all bases are adequately supplied under uncertain threat conditions.''}

\item[Turn 2 --- System (internal):] \hfill \\
Entities added: \texttt{forward\_operating\_bases}, \texttt{supply\_vehicles}, \texttt{routes}, \texttt{delivery\_time}, \texttt{threat\_conditions}. Goal: \texttt{optimization} $\rightarrow$ algorithm: \textbf{QAOA}. Activation threshold met. Status: \texttt{DRAFT} $\rightarrow$ \texttt{ACTIVE}. QAOA circuit: $n = 12$ qubits, $p = 2$ layers.

\item[Turn 2 --- System (response):] \hfill \\
\textit{``System model: Military---Supply Chain Logistics, 5 FOBs, 12 vehicles, 8 routes with threat conditions. Objective: minimize delivery time via QAOA encoding vehicle-route assignments as qubit states. Your digital twin is now active.''}

\end{description}
